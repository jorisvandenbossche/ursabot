# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import worker, steps, changes, schedulers, util, reporters

from ursabot.docker import arrow_images

try:
    from local import (PRODUCTION, BUILDBOT_URL, ZULIP, EMAIL, WORKER_PORT,
                       HOSTS, WEBUI_PORT, AUTH, AUTHZ, DATABASE_URL,
                       WORKER_PASSWORD)
except:
    from buildbot.www.auth import NoAuth
    PRODUCTION = False
    BUILDBOT_URL = 'http://localhost:9011/'
    DATABASE_URL = 'sqlite:///buildbot.sqlite'
    EMAIL = 'test@buildbot'
    ZULIP = None
    HOSTS = None
    WORKER_PORT = 9021
    WEBUI_PORT = 8080
    AUTH = NoAuth()
    AUTHZ = util.Authz()

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').
c['title'] = 'Apache Arrow'
c['titleURL'] = 'https://github.com/apache/arrow'
c['buildbotURL'] = BUILDBOT_URL

c['workers'] = []
c['builders'] = []
c['schedulers'] = []

####### WORKERS

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that
# workers could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': WORKER_PORT}}

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

if HOSTS:
    c['workers'] = [
        worker.Worker('dgx1', WORKER_PASSWORD)
    ]

    # Add docker latent workers, We'll have a worker per docker image on each
    # host supporting tha image's architecture.
    for host, attribs in HOSTS.items():
        for arch, image in arrow_images:
            # Check that architecture is supported by the host machine.
            # Docker on mac supports multiple architectures whereas docker on
            # linux doesn't.
            if arch in attribs.get('docker_archs', set()):
                w = worker.DockerLatentWorker(
                    f'{host}-{image.repo}', None,
                    docker_host=attribs['docker_host'],
                    image=f'ursalab/{image.repo}',
                    autopull=True,
                    alwaysPull=True,
                    hostconfig=dict(network_mode='host')
                )
                c['workers'].append(w)
else:
    c['workers'] = [worker.Worker('test-worker', 'test-secret')]


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = [
    changes.GitPoller(
        'https://github.com/apache/arrow',
        workdir='gitpoller-workdir',
        branch='master',
        pollInterval=300
    )
]

####### SCHEDULERS

if HOSTS:
    builders = [
        'simple-compile',
        'echo-any',
        'echo-dgx1',
        'echo-dgx2',
        'echo-jetson1'
    ]

    c['schedulers'] = [
        schedulers.SingleBranchScheduler(
            name='all',
            change_filter=util.ChangeFilter(branch='master'),
            treeStableTimer=None,
            builderNames=builders
        ),
        schedulers.ForceScheduler(
            name='force',
            builderNames=builders
        )
    ]
else:
    # for testing
    c['schedulers'] = [
        schedulers.ForceScheduler(
            name='force',
            builderNames=['test-builder']
        )
    ]

####### FACTORIES

from ursabot.factories import factory, echo_factory


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.


if HOSTS:
    cpp_worker_names = [w.name for w in c['workers']
                        if w.name.endswith('-cpp')]
    c['builders'] = [
        util.BuilderConfig(
            name='cpp-ninja',
            workernames=cpp_worker_names,
            factory=factory
        ),
        util.BuilderConfig(
            name='echo-dgx1',
            workernames=['dgx1-docker'],
            factory=echo_factory
        ),
        util.BuilderConfig(
            name='echo-dgx2',
            workernames=['dgx2-docker'],
            factory=echo_factory
        ),
        util.BuilderConfig(
            name='echo-jetson1',
            workernames=['jetson1-docker'],
            factory=echo_factory
        )
    ]
else:
    # for testing
    c['builders'] = [
        util.BuilderConfig(
            name='test-builder',
            workernames=['test-worker'],
            factory=echo_factory
        )
    ]


####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['result'] }}</p>
{% endfor %}
<p><b> -- The Buildbot</b></p>
'''

if ZULIP:
    c['services'] = [
        reporters.MailNotifier(
            fromaddr=EMAIL,
            sendToInterestedUsers=False,
            extraRecipients=[ZULIP],
            messageFormatter=reporters.MessageFormatter(
                template=template,
                template_type='html',
                wantProperties=True,
                wantSteps=True
            )
        )
    ]

# minimalistic config to activate new web UI
c['www'] = dict(
    port=WEBUI_PORT,
    auth=AUTH,
    authz=AUTHZ,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={}
    )
)

####### DB URL

c['db'] =  {'db_url' : DATABASE_URL}
