# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import worker, steps, changes, schedulers, util, reporters

try:
    from local import (PRODUCTION, BUILDBOT_URL, ZULIP, EMAIL, WORKER_PORT,
                       HOSTS, WEBUI_PORT, AUTH, AUTHZ, DATABASE_URL,
                       WORKER_PASSWORD)
except:
    from buildbot.www.auth import NoAuth
    PRODUCTION = False
    BUILDBOT_URL = 'http://localhost:9011/'
    DATABASE_URL = 'sqlite:///buildbot.sqlite'
    EMAIL = 'test@buildbot'
    ZULIP = None
    HOSTS = None
    WORKER_PORT = 9021
    WEBUI_PORT = 8080
    AUTH = NoAuth()
    AUTHZ = util.Authz()

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').
c['title'] = 'Apache Arrow'
c['titleURL'] = 'https://github.com/apache/arrow'
c['buildbotURL'] = BUILDBOT_URL

c['workers'] = []
c['builders'] = []
c['schedulers'] = []

####### WORKERS

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that
# workers could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': WORKER_PORT}}

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

if HOSTS:
    c['workers'] = [
        worker.Worker('dgx1', WORKER_PASSWORD),
        worker.DockerLatentWorker(
            'dgx1-docker', None,
            docker_host=HOSTS['dgx1']['docker_host'],
            image='ursalab/amd64-ubuntu-18.04-cpp',
            autopull=True,
            alwaysPull=True,
            hostconfig=dict(network_mode='host')
        ),
        worker.DockerLatentWorker(
            'dgx2-docker', None,
            docker_host=HOSTS['dgx2']['docker_host'],
            image='ursalab/amd64-alpine-3.8-cpp',
            autopull=True,
            alwaysPull=True,
            hostconfig=dict(network_mode='host')
        ),
        worker.DockerLatentWorker(
            'jetson1-docker', None,
            docker_host=HOSTS['jetson1']['docker_host'],
            image='ursalab/arm64v8-ubuntu-18.04-cpp',
            autopull=True,
            alwaysPull=True,
            hostconfig=dict(network_mode='host')
        ),
        worker.DockerLatentWorker(
            'dgx1-docker-dind', None,
            docker_host=HOSTS['dgx1']['docker_host'],
            image='ursalab/amd64-ubuntu-18.04-cpp',
            autopull=True,
            alwaysPull=True,
            hostconfig=dict(network_mode='host')
        )
    ]
else:
    c['workers'] = [worker.Worker('test-worker', 'test-secret')]

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = [
    changes.GitPoller(
        'https://github.com/apache/arrow',
        workdir='gitpoller-workdir',
        branch='master',
        pollInterval=300
    )
]

####### SCHEDULERS

if HOSTS:
    builders = [
        'simple-compile',
        'echo-any',
        'echo-dgx1',
        'echo-dgx2',
        'echo-jetson1'
    ]

    c['schedulers'] = [
        schedulers.SingleBranchScheduler(
            name='all',
            change_filter=util.ChangeFilter(branch='master'),
            treeStableTimer=None,
            builderNames=builders
        ),
        schedulers.ForceScheduler(
            name='force',
            builderNames=builders
        )
    ]
else:
    # for testing
    c['schedulers'] = [
        schedulers.ForceScheduler(
            name='force',
            builderNames=['test-builder']
        )
    ]

####### STEPS

checkout = steps.Git(
    repourl='https://github.com/apache/arrow',
    mode='incremental'
)
mkdir = steps.MakeDirectory(
    dir='build'
)
ls = steps.ShellCommand(
    command=['ls', '-lah']
)
cmake = steps.CMake(
    path='cpp',
    generator='Unix Makefiles',
    definitions={
        'CMAKE_BUILD_TYPE': 'debug',
        'ARROW_BUILD_TESTS': 'ON'
    },
    workdir='build'
)
compile = steps.Compile(
    command=['make'],
    workdir='build'
)
test = steps.Compile(
    command=['make', 'test'],
    workdir='build'
)

echo = steps.ShellCommand(
    command=['echo', 'testing...']
)

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.


factory = util.BuildFactory()
factory.addStep(checkout)
factory.addStep(ls)
factory.addStep(mkdir)
factory.addStep(cmake)
factory.addStep(compile)
factory.addStep(test)

echo_factory = util.BuildFactory()
echo_factory.addStep(checkout)
echo_factory.addStep(ls)
echo_factory.addStep(echo)


if HOSTS:
    c['builders'] = [
        util.BuilderConfig(
            name='simple-compile',
            workernames=['dgx1-docker'],
            factory=factory
        ),
        util.BuilderConfig(
            name='echo-any',
            workernames=['dgx1-docker', 'dgx2-docker', 'jetson1-docker'],
            factory=echo_factory
        ),
        util.BuilderConfig(
            name='echo-dgx1',
            workernames=['dgx1-docker'],
            factory=echo_factory
        ),
        util.BuilderConfig(
            name='echo-dgx2',
            workernames=['dgx2-docker'],
            factory=echo_factory
        ),
        util.BuilderConfig(
            name='echo-jetson1',
            workernames=['jetson1-docker'],
            factory=echo_factory
        )
    ]
else:
    # for testing
    c['builders'] = [
        util.BuilderConfig(
            name='test-builder',
            workernames=['test-worker'],
            factory=echo_factory
        )
    ]


####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['result'] }}</p>
{% endfor %}
<p><b> -- The Buildbot</b></p>
'''

if ZULIP:
    c['services'] = [
        reporters.MailNotifier(
            fromaddr=EMAIL,
            sendToInterestedUsers=False,
            extraRecipients=[ZULIP],
            messageFormatter=reporters.MessageFormatter(
                template=template,
                template_type='html',
                wantProperties=True,
                wantSteps=True
            )
        )
    ]

# minimalistic config to activate new web UI
c['www'] = dict(
    port=WEBUI_PORT,
    auth=AUTH,
    authz=AUTHZ,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={}
    )
)

####### DB URL

c['db'] =  {'db_url' : DATABASE_URL}
